---
title: "Crafting a JSON parser with SIMD: Descent into madness"
excerpt: "Let me guide you through how what I thought would take up 20mins ended up being more than I bargained for"
coverImage: ""
date: "2024-04-21T20:55:00.000Z"
---

In the first post of this series I mentioned how this function:

```lisp
(defun unset-rightmost-bit (n)
  (declare (type fixnum n))
  (the fixnum (logand n (- n 1))))
```

could probably be written as a simple assembly instruction. Let me guide you through how what I thought would take up 20mins ended up being more than I bargained for.

# It's just another VOP right?

So the instruction we are looking at is `BLSR` which just unsets the rightmost set bit, exactly what we need. Let's just create a VOP to use it, much like we did for `BSF`:

```lisp
(in-package :cl-user)

(sb-c:defknown unset-rightmost-bit ((unsigned-byte 64)) (integer 0 64)
    (sb-c:foldable sb-c:flushable sb-c:movable)
  :overwrite-fndb-silently t)

(in-package :sb-vm)

(define-vop (cl-user::unset-rightmost-bit)
  (:policy :fast)
  (:translate cl-user::unset-rightmost-bit)
  (:args (x :scs (any-reg) :target r))
  (:arg-types positive-fixnum)
  (:results (r :scs (unsigned-reg)))
  (:result-types positive-fixnum)
  (:generator 1
    (inst blsr x r)))

(in-package :cl-user)

(defun sth (a)
  (declare (type fixnum a)
           (optimize (speed 3) (safety 0)))
  (unset-rightmost-bit a))
```

which fails with:

```lisp
Undefined instruction: BLSR in
 (INST BLSR X R)
```

Huh!? Grepping through the SBCL repo for `BLSR` does not match anything... Turns out, the compiler does not know how to emit that instruction. But at this point I'm invested. I don't want to just give up and call it a day, which, in hindsight, would have been the wise thing to do... Let's look at how `BSF` was defined as an instruction and just imitate that.

# Teaching the compiler new words

Here is how `BSF` was taught to the compiler:

```lisp
(define-instruction bsf (segment &prefix prefix dst src)
  (:printer ext-reg-reg/mem-no-width ((op #xBC)))
  (:emitter (emit* segment #xBC prefix dst src)))
```

For the compiler to be able to emit an assembly instruction, it must know the bytes of machine code that correspond to it. How do we know what bytes to emit? Open the (Intel)[https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html]/(AMD)[https://www.amd.com/content/dam/amd/en/documents/processor-tech-docs/programmer-references/24594.pdf] Developer Manual, find the instructions page and look at the opcode.


|Opcode|Instruction|Op/En|64-bit Mode |Compat/Leg Mode|Description|
| --- | --- | --- | --- | --- | --- |
|0F BC /r|BSF r16, r/m16|RM|Valid|Valid|Bit scan forward on r/m16.|
|0F BC /r|BSF r32, r/m32|RM|Valid|Valid|Bit scan forward on r/m32.|
|REX.W + 0F BC|/r BSF r64, r/m64|RM|Valid|N.E.|Bit scan forward on r/m64.|
