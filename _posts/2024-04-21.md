---
title: "Crafting a JSON parser with SIMD: Descent into madness"
excerpt: "Let me guide you through how what I thought would take up 20mins ended up being more than I bargained for"
coverImage: ""
date: "2024-04-21T20:55:00.000Z"
---

In the first post of this series I mentioned how this function:

```lisp
(defun unset-rightmost-bit (n)
  (declare (type fixnum n))
  (the fixnum (logand n (- n 1))))
```

could probably be written as a simple assembly instruction. Let me guide you through how what I thought would take up 20mins ended up being more than I bargained for.

# It's just another VOP right?

So the instruction we are looking at is `BLSR` which just unsets the rightmost set bit, exactly what we need. Let's just create a VOP to use it, much like we did for `BSF`:

```lisp
(in-package :cl-user)

(sb-c:defknown unset-rightmost-bit ((unsigned-byte 64)) (integer 0 64)
    (sb-c:foldable sb-c:flushable sb-c:movable)
  :overwrite-fndb-silently t)

(in-package :sb-vm)

(define-vop (cl-user::unset-rightmost-bit)
  (:policy :fast)
  (:translate cl-user::unset-rightmost-bit)
  (:args (x :scs (any-reg) :target r))
  (:arg-types positive-fixnum)
  (:results (r :scs (unsigned-reg)))
  (:result-types positive-fixnum)
  (:generator 1
    (inst blsr x r)))

(in-package :cl-user)

(defun sth (a)
  (declare (type fixnum a)
           (optimize (speed 3) (safety 0)))
  (unset-rightmost-bit a))
```

which fails with:

```lisp
Undefined instruction: BLSR in
 (INST BLSR X R)
```

Huh!? Grepping through the SBCL repo for `BLSR` does not match anything... Turns out, the compiler does not know how to emit that instruction. But at this point I'm invested. I don't want to just give up and call it a day, which, in hindsight, would have been the wise thing to do... Let's look at how `BSF` was defined as an instruction and just imitate that.

# Teaching the compiler new words

I've already complained that SIMD and define-vop don't really come with any documentation except for a few sources and examples. Well `define-instruction` is not something I could really find anything on besides inside the SBCL source code. The plan is to look at some examples and hopefully grab one that looks close, adjust it and have it work.

## Looking at existing instructions

### BSF
Here is how `BSF` was taught to the compiler:

```lisp
(define-instruction bsf (segment &prefix prefix dst src)
  (:printer ext-reg-reg/mem-no-width ((op #xBC)))
  (:emitter (emit* segment #xBC prefix dst src)))
```

For the compiler to be able to emit an assembly instruction, it must know the bytes of machine code that correspond to it. How do we know what bytes to emit? Open the [Intel](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html)/[AMD](https://www.amd.com/content/dam/amd/en/documents/processor-tech-docs/programmer-references/24594.pdf) Developer Manual, find the instructions page and look at the opcode.

|Opcode|Instruction|Op/En|64-bit Mode |Compat/Leg Mode|Description|
| --- | --- | --- | --- | --- | --- |
|0F BC /r|BSF r16, r/m16|RM|Valid|Valid|Bit scan forward on r/m16.|
|0F BC /r|BSF r32, r/m32|RM|Valid|Valid|Bit scan forward on r/m32.|
|REX.W + 0F BC|/r BSF r64, r/m64|RM|Valid|N.E.|Bit scan forward on r/m64.|

Looking at the table in Intel's manual, the first 2 entries are pretty straight-forward, the instruction corresponds to bytes `0x0F 0xBC`, that's the opcode. `/r` is part of the [ModR/M byte](https://en.wikipedia.org/wiki/ModR/M). This is emitted after the opcode and encodes information about the instruction operands.

The third one is where things get more complicated. Some instructions require a prefix before the opcode. To use `BSF` with 64bit integers you need to first emit the [REX](https://en.wikipedia.org/wiki/VEX_prefix#REX) prefix with the `W` flag set to `1`. I think in this case it would be `0b01001000`.

This is a lot of information, I know it was for me but here is the recap for machine code instruction format:
```lisp
[PREFIX] OPCODE MOD_RM
```

_I am no expert and this might be lacking but it was good enough to guide me to a result and it should be enough to follow along._

Time to pull up the same table for `BLSR` and see if it's making any sense.

|Opcode/Instruction|Op/En|64/32-bit Mode|CPUID Feature Flag|Description|
|---|---|---|---|---|
|VEX.LZ.0F38.W0 F3 /1 BLSR r32, r/m32|VM|V/V|BMI1|Reset lowest set bit of r/m32, keep all other bits of r/m32 and write result to r32.|
|VEX.LZ.0F38.W1 F3 /1 BLSR r64, r/m64|VM|V/N.E.|BMI1|Reset lowest set bit of r/m64, keep all other bits of r/m64 and write result to r64.|

This is starting to feel a lot like the difference between what's given for homework and what's on the final test...

## VEX

To my dismay, [VEX](https://en.wikipedia.org/wiki/VEX_prefix#VEX3) is far more complicated than REX...
